/* -*- c++ -*- */
/*
 * Copyright 2018 Lucas Teske <lucas@teske.com.br>
 *   Based on Youssef Touil (youssef@live.com) C# implementation.
 *
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdexcept>
#include <iostream>
#include <algorithm>

#include <boost/assign.hpp>
#include <boost/format.hpp>
#include <boost/detail/endian.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/thread/thread.hpp>

#include <gnuradio/io_signature.h>

#include "spyserver_source_c.h"
#include "spyserver_protocol.h"

#include "arg_helpers.h"

using namespace boost::assign;

spyserver_source_c_sptr make_spyserver_source_c (const std::string & args)
{
  return gnuradio::get_initial_sptr(new spyserver_source_c (args));
}

/*
 * Specify constraints on number of input and output streams.
 * This info is used to construct the input and output signatures
 * (2nd & 3rd args to gr::block's constructor).  The input and
 * output signatures are used by the runtime system to
 * check that a valid number and type of inputs and outputs
 * are connected to this block.  In this case, we accept
 * only 0 input and 1 output.
 */
static const int MIN_IN = 0;  // mininum number of input streams
static const int MAX_IN = 0;  // maximum number of input streams
static const int MIN_OUT = 1; // minimum number of output streams
static const int MAX_OUT = 1; // maximum number of output streams

/*
 * The private constructor
 */
spyserver_source_c::spyserver_source_c (const std::string &args)
  : gr::sync_block ("spyserver_source_c",
        gr::io_signature::make(MIN_IN, MAX_IN, sizeof (gr_complex)),
        gr::io_signature::make(MIN_OUT, MAX_OUT, sizeof (gr_complex))),
    _sample_rate(0),
    _center_freq(0),
    _freq_corr(0),
    _auto_gain(false)
{
  dict_t dict = params_to_dict(args);

  connect();

  for (size_t i = 0; i < _sample_rates.size(); i++)
    std::cerr << boost::format("%gM ") % (_sample_rates[i].first / 1e6);

  set_center_freq( (get_freq_range().start() + get_freq_range().stop()) / 2.0 );
  set_sample_rate( get_sample_rates().start() );
  set_bandwidth( 0 );

  set_lna_gain( 8 ); /* preset to a reasonable default (non-GRC use case) */

  if (dict.count("ip"))
  {
    ip = boost::lexical_cast<std::string>( dict["ip"] );
  }
  else
  {
    throw std::runtime_error( std::string(__FUNCTION__) + " " +
                              "You should defined an IP to connect." );
  }

  if (dict.count("port"))
  {
    port = boost::lexical_cast<int>( dict["port"] );
  }
  else
  {
    port = 5555;
  }

  client = tcp_client(ip, port);

  _fifo = new boost::circular_buffer<gr_complex>(5000000);
  if (!_fifo) {
    throw std::runtime_error( std::string(__FUNCTION__) + " " +
                              "Failed to allocate a sample FIFO!" );
  }
}

// const std::string &spyserver_source_c::getName() {
//   switch (deviceInfo.DeviceType) {
//   case DEVICE_INVALID:
//     return spyserver_source_c::NameNoDevice;
//   case DEVICE_AIRSPY_ONE:
//     return spyserver_source_c::NameAirspyOne;
//   case DEVICE_AIRSPY_HF:
//     return spyserver_source_c::NameAirspyHF;
//   case DEVICE_RTLSDR:
//     return spyserver_source_c::NameRTLSDR;
//   default:
//     return spyserver_source_c::NameUnknown;
//   }
// }

void spyserver_source_c::connect()
{
  bool hasError = false;
  if (receiverThread != NULL) {
    return;
  }

  std::cerr << "SpyServer: Trying to connect" << std::endl;
  client.connect_conn();
  isConnected = true;
  std::cerr << "SpyServer: Connected" << std::endl;

  sayHello();
  cleanup();

  terminated = false;
  gotSyncInfo = false;
  gotDeviceInfo = false;

  std::exception error;

  receiverThread  = new std::thread(&spyserver_source_c::threadLoop, this);

  for (int i=0; i<1000 && !hasError; i++) {
    if (gotDeviceInfo) {
      if (deviceInfo.DeviceType == DEVICE_INVALID) {
        error = std::runtime_error( std::string(__FUNCTION__) + " " + "Server is up but no device is available");
        hasError = true;
        break;
      }

      if (gotSyncInfo) {
        std::cerr << "SpyServer: Got sync Info" << std::endl;
        onConnect();
        return;
      }
    }
    std::this_thread::sleep_for(std::chrono::milliseconds(1));
  }

  disconnect();
  if (hasError) {
    throw error;
  }

  throw std::runtime_error( std::string(__FUNCTION__) + " " + "Server didn't send the device capability and synchronization info.");
}

void spyserver_source_c::disconnect()
{
  terminated = true;
  if (isConnected) {
    client.close_conn();
  }

  if (receiverThread != NULL) {
    receiverThread->join();
    receiverThread = NULL;
  }

  cleanup();
}


void spyserver_source_c::onConnect()
{
  setSetting(SETTING_STREAMING_MODE, { streamingMode });
  setSetting(SETTING_IQ_FORMAT, { STREAM_FORMAT_INT16 });
  setSetting(SETTING_FFT_FORMAT, { STREAM_FORMAT_UINT8 });
  //setSetting(SETTING_FFT_DISPLAY_PIXELS, { displayPixels });
  //setSetting(SETTING_FFT_DB_OFFSET, { fftOffset });
  //setSetting(SETTING_FFT_DB_RANGE, { fftRange });
  //deviceInfo.MaximumSampleRate
  //availableSampleRates
  for (unsigned int i=0; i<=deviceInfo.DecimationStageCount; i++) {
    _sample_rates.push_back( std::pair<double, uint32_t>(deviceInfo.MaximumSampleRate / (double)(1 << i), i ) );
  }
  std::sort(_sample_rates.begin(), _sample_rates.end());
}

bool spyserver_source_c::setSetting(uint32_t settingType, std::vector<uint32_t> params) {
  std::vector<uint8_t> argBytes;
  if (params.size() > 0) {
    argBytes = std::vector<uint8_t>(sizeof(SettingType) + params.size() * sizeof(uint32_t));
    uint8_t *settingBytes = (uint8_t *) &settingType;
    for (unsigned int i=0; i<sizeof(uint32_t); i++) {
      argBytes[i] = settingBytes[i];
    }

    std::memcpy(&argBytes[0]+sizeof(uint32_t), &params[0], sizeof(uint32_t) * params.size());
  } else {
    argBytes = std::vector<uint8_t>();
  }

  return sendCommand(CMD_SET_SETTING, argBytes);
}

bool spyserver_source_c::sayHello() {
  const uint8_t *protocolVersionBytes = (const uint8_t *) &ProtocolVersion;
  const uint8_t *softwareVersionBytes = (const uint8_t *) SoftwareID.c_str();
  std::vector<uint8_t> args = std::vector<uint8_t>(sizeof(ProtocolVersion) + SoftwareID.size());

  std::memcpy(&args[0], protocolVersionBytes, sizeof(ProtocolVersion));
  std::memcpy(&args[0] + sizeof(ProtocolVersion), softwareVersionBytes, SoftwareID.size());

  return sendCommand(CMD_HELLO, args);
}

void spyserver_source_c::cleanup() {
    deviceInfo.DeviceType = 0;
    deviceInfo.DeviceSerial = 0;
    deviceInfo.DecimationStageCount = 0;
    deviceInfo.GainStageCount = 0;
    deviceInfo.MaximumSampleRate = 0;
    deviceInfo.MaximumBandwidth = 0;
    deviceInfo.MaximumGainIndex = 0;
    deviceInfo.MinimumFrequency = 0;
    deviceInfo.MaximumFrequency = 0;

    gain = 0;
    //displayCenterFrequency = 0;
    //deviceCenterFrequency = 0;
    //displayDecimationStageCount = 0;
    //channelDecimationStageCount = 0;
    //minimumTunableFrequency = 0;
    //maximumTunableFrequency = 0;
    canControl = false;
    gotDeviceInfo = false;
    gotSyncInfo = false;

    lastSequenceNumber = ((uint32_t)-1);
    droppedBuffers = 0;
    down_stream_bytes = 0;

    parserPhase = AcquiringHeader;
    parserPosition = 0;

    streaming = false;
    terminated = true;
}


void spyserver_source_c::threadLoop() {
  parserPhase = AcquiringHeader;
  parserPosition = 0;

  char buffer[BufferSize];
  try {
    while(!terminated) {
      if (terminated) {
        break;
      }
      uint32_t availableData = client.available_data();
      if (availableData > 0) {
        availableData = availableData > BufferSize ? BufferSize : availableData;
        client.receive_data(buffer, availableData);
        parseMessage(buffer, availableData);
      }
    }
  } catch (std::exception &e) {
    std::cerr << "SpyServer: Error on ThreadLoop: " << e.what() << std::endl;
    // std::cerr << e.what() << std::endl;
  }
  if (bodyBuffer != NULL) {
    delete[] bodyBuffer;
    bodyBuffer = NULL;
  }

  cleanup();
}

void spyserver_source_c::parseMessage(char *buffer, uint32_t len) {
  down_stream_bytes++;

  int consumed;
  while (len > 0 && !terminated) {
    if (parserPhase == AcquiringHeader) {
      while (parserPhase == AcquiringHeader && len > 0) {
        consumed = parseHeader(buffer, len);
        buffer += consumed;
        len -= consumed;
      }

      if (parserPhase == ReadingData) {
        uint8_t client_major = (SPYSERVER_PROTOCOL_VERSION >> 24) & 0xFF;
        uint8_t client_minor = (SPYSERVER_PROTOCOL_VERSION >> 16) & 0xFF;

        uint8_t server_major = (header.ProtocolID >> 24) & 0xFF;
        uint8_t server_minor = (header.ProtocolID >> 16) & 0xFF;
        //uint16_t server_build = (header.ProtocolID & 0xFFFF);

        if (client_major != server_major || client_minor != server_minor) {
          throw std::runtime_error( std::string(__FUNCTION__) + " " + "Server is running an unsupported protocol version.");
        }

        if (header.BodySize > SPYSERVER_MAX_MESSAGE_BODY_SIZE) {
          throw std::runtime_error( std::string(__FUNCTION__) + " " + "The server is probably buggy.");
        }

        if (bodyBuffer == NULL || bodyBufferLength < header.BodySize) {
          if (bodyBuffer != NULL) {
            delete[] bodyBuffer;
          }

          bodyBuffer = new uint8_t[header.BodySize];
        }
      }
    }

    if (parserPhase == ReadingData) {
      consumed = parseBody(buffer, len);
      buffer += consumed;
      len -= consumed;

      if (parserPhase == AcquiringHeader) {
        if (header.MessageType != MSG_TYPE_DEVICE_INFO && header.MessageType != MSG_TYPE_CLIENT_SYNC) {
          int32_t gap = header.SequenceNumber - lastSequenceNumber - 1;
          lastSequenceNumber = header.SequenceNumber;
          droppedBuffers += gap;
          if (gap > 0) {
            std::cerr << "SpyServer: Lost " << gap << " frames from SpyServer!";
          }
        }
        handleNewMessage();
      }
    }
  }
}

int spyserver_source_c::parseHeader(char *buffer, uint32_t length) {
  auto consumed = 0;

  while (length > 0) {
    int to_write = std::min((uint32_t)(sizeof(MessageHeader) - parserPosition), length);
    std::memcpy(&header + parserPosition, buffer, to_write);
    length -= to_write;
    buffer += to_write;
    parserPosition += to_write;
    consumed += to_write;
    if (parserPosition == sizeof(MessageHeader)) {
      parserPosition = 0;
      if (header.BodySize > 0) {
        parserPhase = ReadingData;
      }

      return consumed;
    }
  }

  return consumed;
}

int spyserver_source_c::parseBody(char* buffer, uint32_t length) {
  auto consumed = 0;

  while (length > 0) {
    int to_write = std::min((int) header.BodySize - parserPosition, length);
    std::memcpy(bodyBuffer + parserPosition, buffer, to_write);
    length -= to_write;
    buffer += to_write;
    parserPosition += to_write;
    consumed += to_write;

    if (parserPosition == header.BodySize) {
      parserPosition = 0;
      parserPhase = AcquiringHeader;
      return consumed;
    }
  }

  return consumed;
}

bool spyserver_source_c::sendCommand(uint32_t cmd, std::vector<uint8_t> args) {
  if (!isConnected) {
    return false;
  }

  bool result;
  uint32_t headerLen = sizeof(CommandHeader);
  uint16_t argLen = args.size();
  uint8_t *buffer = new uint8_t[headerLen + argLen];

  CommandHeader header;
  header.CommandType = cmd;
  header.BodySize = argLen;

  for (uint32_t i=0; i<sizeof(CommandHeader); i++) {
    buffer[i] = ((uint8_t *)(&header))[i];
  }

  if (argLen > 0) {
    for (uint16_t i=0; i<argLen; i++) {
      buffer[i+headerLen] = args[i];
    }
  }

  try {
    client.send_data((char *)buffer, headerLen+argLen);
    result = true;
  } catch (std::exception &e) {
    result = false;
  }

  delete[] buffer;
  return result;
}

void spyserver_source_c::handleNewMessage() {
  if (terminated) {
    return;
  }

  switch (header.MessageType) {
    case MSG_TYPE_DEVICE_INFO:
      processDeviceInfo();
      break;
    case MSG_TYPE_CLIENT_SYNC:
      processClientSync();
      break;
    case MSG_TYPE_UINT8_IQ:
      processUInt8Samples();
      break;
    case MSG_TYPE_INT16_IQ:
      processInt16Samples();
      break;
    case MSG_TYPE_FLOAT_IQ:
      processFloatSamples();
      break;
    case MSG_TYPE_UINT8_FFT:
      processUInt8FFT();
      break;
    default:
      break;
  }
}

void spyserver_source_c::processDeviceInfo() {
  std::memcpy(&deviceInfo, bodyBuffer, sizeof(DeviceInfo));
  minimumTunableFrequency = deviceInfo.MinimumFrequency;
  maximumTunableFrequency = deviceInfo.MaximumFrequency;
  gotDeviceInfo = true;
}

void spyserver_source_c::processClientSync() {
  ClientSync sync;
  std::memcpy(&sync, bodyBuffer, sizeof(ClientSync));

  canControl = sync.CanControl != 0;
  gain = (int) sync.Gain;
  deviceCenterFrequency = sync.DeviceCenterFrequency;
  channelCenterFrequency = sync.IQCenterFrequency;
  //displayCenterFrequency = sync.FFTCenterFrequency;

  switch (streamingMode) {
  case STREAM_MODE_FFT_ONLY:
  case STREAM_MODE_FFT_IQ:
    minimumTunableFrequency = sync.MinimumFFTCenterFrequency;
    maximumTunableFrequency = sync.MaximumFFTCenterFrequency;
    break;
  case STREAM_MODE_IQ_ONLY:
    minimumTunableFrequency = sync.MinimumIQCenterFrequency;
    maximumTunableFrequency = sync.MaximumIQCenterFrequency;
    break;
  }

  gotSyncInfo = true;
}

void spyserver_source_c::processUInt8Samples() {
  size_t n_avail, to_copy, num_samples = (header.BodySize) / 2;
  _fifo_lock.lock();

  uint8_t *sample = (uint8_t *)bodyBuffer;

  n_avail = _fifo->capacity() - _fifo->size();
  to_copy = (n_avail < num_samples ? n_avail : num_samples / 2);

  for (size_t i=0; i < to_copy; i++)
  {
    _fifo->push_back(gr_complex(*sample - 128.f / 128.f, *(sample+1) - 128.f / 128.f));
    sample += 2;
  }
  _fifo_lock.unlock();
    /* We have made some new samples available to the consumer in work() */
  if (to_copy) {
    //std::cerr << "+" << std::flush;
    _samp_avail.notify_one();
  }

  /* Indicate overrun, if neccesary */
  if (to_copy < num_samples)
    std::cerr << "O" << std::flush;
}

void spyserver_source_c::processInt16Samples() {
  size_t n_avail, to_copy, num_samples = (header.BodySize / 2) / 2;
  _fifo_lock.lock();

  int16_t *sample = (int16_t *)bodyBuffer;

  n_avail = _fifo->capacity() - _fifo->size();
  to_copy = (n_avail < num_samples ? n_avail : num_samples);

  for (size_t i=0; i < to_copy; i++)
  {
    _fifo->push_back(gr_complex(*sample / 32768.f, *(sample+1) / 32768.f));
    sample += 2;
  }
  _fifo_lock.unlock();
    /* We have made some new samples available to the consumer in work() */
  if (to_copy) {
    //std::cerr << "+" << std::flush;
    _samp_avail.notify_one();
  }

  /* Indicate overrun, if neccesary */
  if (to_copy < num_samples)
    std::cerr << "O" << std::flush;
}

void spyserver_source_c::processFloatSamples() {
  size_t n_avail, to_copy, num_samples = (header.BodySize / 4) / 2;
  _fifo_lock.lock();

  float *sample = (float *)bodyBuffer;

  n_avail = _fifo->capacity() - _fifo->size();
  to_copy = (n_avail < num_samples ? n_avail : num_samples);

  for (size_t i=0; i < to_copy; i++)
  {
    _fifo->push_back(gr_complex(*sample, *(sample+1)));
    sample += 2;
  }
  _fifo_lock.unlock();
    /* We have made some new samples available to the consumer in work() */
  if (to_copy) {
    //std::cerr << "+" << std::flush;
    _samp_avail.notify_one();
  }
}

void spyserver_source_c::setStreamState() {
  setSetting(SETTING_STREAMING_ENABLED, {(unsigned int)(streaming ? 1 : 0)});
}

double spyserver_source_c::set_sample_rate(double sampleRate) {
  if (sampleRate <= 0xFFFFFFFF) {
    for (unsigned int i=0; i<_sample_rates.size(); i++) {
      if (_sample_rates[i].first == sampleRate) {
              channelDecimationStageCount = i;
              setSetting(SETTING_IQ_DECIMATION, {channelDecimationStageCount});
              return get_sample_rate();
      }
    }
  }
  std::cerr << "SpyServer: Sample rate not supported: " << sampleRate << std::endl;
  std::cerr << "SpyServer: Supported Sample Rates: " << std::endl;
  for (std::pair<double, uint32_t> sr: _sample_rates) {
    std::cerr << "SpyServer:   " << sr.first << std::endl;
  }

  throw std::runtime_error(boost::str( boost::format("Unsupported samplerate: %gM") % (sampleRate/1e6) ) );
}

double spyserver_source_c::set_center_freq(double centerFrequency, size_t chan) {
  if (centerFrequency <= 0xFFFFFFFF) {
    channelCenterFrequency = (uint32_t) centerFrequency;
    setSetting(SETTING_IQ_FREQUENCY, {channelCenterFrequency});
    return centerFrequency;
  }

  throw std::runtime_error(boost::str( boost::format("Unsupported center frequency: %gM") % (centerFrequency/1e6) ) );
}

void spyserver_source_c::processUInt8FFT() {
  // TODO
  // // std::cerr << "UInt8 FFT Samples processing not implemented!!!" << std::endl;
}

/*
 * Our virtual destructor.
 */
spyserver_source_c::~spyserver_source_c ()
{
  disconnect();
  if (_fifo)
  {
    delete _fifo;
    _fifo = NULL;
  }
  delete[] headerData;
  headerData = NULL;
}

bool spyserver_source_c::start()
{
  if (!streaming) {
      streaming = true;
      down_stream_bytes = 0;
      setStreamState();
      return true;
  }
  return false;
}

bool spyserver_source_c::stop()
{
  if (streaming) {
      streaming = false;
      down_stream_bytes = 0;
      setStreamState();
      return true;
  }
  return false;
}

int spyserver_source_c::work( int noutput_items,
                        gr_vector_const_void_star &input_items,
                        gr_vector_void_star &output_items )
{
  gr_complex *out = (gr_complex *)output_items[0];

  if ( ! streaming )
    return WORK_DONE;

  boost::unique_lock<boost::mutex> lock(_fifo_lock);

  /* Wait until we have the requested number of samples */
  int n_samples_avail = _fifo->size();

  while (n_samples_avail < noutput_items) {
    _samp_avail.wait(lock);
    n_samples_avail = _fifo->size();
  }

  for(int i = 0; i < noutput_items; ++i) {
    out[i] = _fifo->at(0);
    _fifo->pop_front();
  }

  //std::cerr << "-" << std::flush;

  return noutput_items;
}

std::vector<std::string> spyserver_source_c::get_devices()
{
  std::vector<std::string> devices;
  std::string label;
  return devices;
}

size_t spyserver_source_c::get_num_channels()
{
  return 1;
}

osmosdr::meta_range_t spyserver_source_c::get_sample_rates()
{
  osmosdr::meta_range_t range;

  for (size_t i = 0; i < _sample_rates.size(); i++)
    range += osmosdr::range_t( _sample_rates[i].first );

  return range;
}

double spyserver_source_c::get_sample_rate()
{
  return _sample_rate;
}

osmosdr::freq_range_t spyserver_source_c::get_freq_range( size_t chan )
{
  osmosdr::freq_range_t range;

  range += osmosdr::range_t( 24e6, 1766e6 );

  return range;
}

double spyserver_source_c::get_center_freq( size_t chan )
{
  return _center_freq;
}

double spyserver_source_c::set_freq_corr( double ppm, size_t chan )
{
  _freq_corr = ppm;

  set_center_freq( _center_freq );

  return get_freq_corr( chan );
}

double spyserver_source_c::get_freq_corr( size_t chan )
{
  return _freq_corr;
}

std::vector<std::string> spyserver_source_c::get_gain_names( size_t chan )
{
  std::vector< std::string > names;

  names += "LNA";

  return names;
}

osmosdr::gain_range_t spyserver_source_c::get_gain_range( size_t chan )
{
  return osmosdr::gain_range_t( 0, 21, 1 );
}

osmosdr::gain_range_t spyserver_source_c::get_gain_range( const std::string & name, size_t chan )
{
  /* They don't spec any gain values in dB so we simply use gain stage indices for now. */

  if ( "LNA" == name ) {
    return osmosdr::gain_range_t( 0, 15, 1 );
  }

  return osmosdr::gain_range_t();
}

bool spyserver_source_c::set_gain_mode( bool automatic, size_t chan )
{
  return get_gain_mode(chan);
}

bool spyserver_source_c::get_gain_mode( size_t chan )
{
  return _auto_gain;
}

double spyserver_source_c::set_gain( double gain, size_t chan )
{
  _gain = gain;
  setSetting(SETTING_GAIN, {(uint32_t)gain});
  return _gain;
}

double spyserver_source_c::set_lna_gain( double gain, size_t chan) 
{
  return set_gain(gain);
}

double spyserver_source_c::set_gain( double gain, const std::string & name, size_t chan)
{
  if ( "LNA" == name ) {
    return set_lna_gain( gain, chan );
  }

  return set_gain( gain, chan );
}

double spyserver_source_c::get_gain( size_t chan )
{
  return _gain;
}

double spyserver_source_c::get_gain( const std::string & name, size_t chan )
{
  if ( "LNA" == name ) {
    return _gain;
  }

  return get_gain( chan );
}

double spyserver_source_c::set_mix_gain(double gain, size_t chan)
{
  return 0;
}

double spyserver_source_c::set_if_gain(double gain, size_t chan)
{
  return 0;
}

std::vector< std::string > spyserver_source_c::get_antennas( size_t chan )
{
  std::vector< std::string > antennas;

  antennas += get_antenna( chan );

  return antennas;
}

std::string spyserver_source_c::set_antenna( const std::string & antenna, size_t chan )
{
  return get_antenna( chan );
}

std::string spyserver_source_c::get_antenna( size_t chan )
{
  return "RX";
}

double spyserver_source_c::set_bandwidth( double bandwidth, size_t chan )
{
  return get_bandwidth( chan );
}

double spyserver_source_c::get_bandwidth( size_t chan )
{
  return _sample_rate;
}

osmosdr::freq_range_t spyserver_source_c::get_bandwidth_range( size_t chan )
{
  osmosdr::freq_range_t bandwidths;

  bandwidths += osmosdr::range_t( get_bandwidth( chan ) );

  return bandwidths;
}

void spyserver_source_c::set_biast( bool enabled ) {
  // _biasT = enabled;
}

bool spyserver_source_c::get_biast() {
  return false; // _biasT;
}